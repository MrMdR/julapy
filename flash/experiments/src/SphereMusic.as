package  {		import fl.motion.easing.*;	import flash.display.Sprite;	import flash.events.Event;		public class SphereMusic extends Sprite 	{		// Constants:		// Public Properties:		// Private Properties:		var circles:Vector.<SphereMusicCircle>;		var sphere:Sprite;		var soundChannel:SoundChannel;		var rotY:Number=0;		var rotZ:Number=0;				// UI Elements:				// Initialization:		public function SphereMusic() {			stage.quality = "low";			loadMusic();			buildSphere();			addEventListener(Event.ENTER_FRAME,tick);		}		// Public Methods:		// Protected Methods:		// Private Methods:		private function buildSphere():void {			circles = new Vector.<SphereMusicCircle>();			sphere = new Sprite();			sphere.x = sphere.y = 275;			sphere.z = 200;			addChild(sphere);						var count:uint=0;			for (var i:int=0; i< 8*16; i++) {				var rX:Number = (i%16);				var rY:Number = (i/16>>0);								// skip extra circles on and around the poles				if (rY > 0 && (rX == 0 || rX == 8) || ((rY%2==0 && (rX == 1 || rX == 9 || rX == 7 || rX == 15)))) {					continue;				}								// draw circles double size because player 10 will rasterize them:				var circle:SphereMusicCircle = new SphereMusicCircle(0.5);				circle.dot1.z = 200;				circle.dot2.z = 300;				circle.line1.rotationZ = i/128*360;				circle.rotationY = rX*(360/16);				circle.rotationZ = rY*(180/8);				// slight offset to make it roll:				circle.z = 100;								circles.push(circle);				sphere.addChild(circle);								// sphere to disc tweening fun:				var rnd:Number = rX%8/8;//Math.random();				var rnd2:Number = count/98*Math.PI*2;				new GTween(circle,rnd*4+1,{rotationZ:0,rotationY:count/98*360, x:Math.sin(rnd2)*180, z:Math.cos(rnd2)*180+100},{autoReverse:true,delay:4-rnd*4+4,ease:Quadratic.easeInOut});								// also cool, twisty:				//new GTween(circle,rnd*3+1,{rotationZ:count/98*720-360,rotationY:count/98*360},{autoReverse:true,delay:3-rnd*3+2,ease:Sine.easeIn});								// also also cool, snowflake:				/*				var rnd:Number = rX%8/8;//Math.random();				var rnd2:Number = rnd*Math.PI*2;				new GTween(circle,rnd*2+1,{rotationZ:0,rotationY:count/98*360, x:Math.sin(rnd2)*180, z:Math.cos(rnd2)*180},{autoReverse:true,delay:2-rnd*2+2,ease:Quadratic.easeInOut});				*/								count++;			}		}				public function tick(evt:Event):void {			var volume:Number = (soundChannel.leftPeak+soundChannel.rightPeak)/2;			sphere.z = Math.min(3000-volume*3200,sphere.z+40);						rotZ += (soundChannel.leftPeak-0.2)*0.5;			rotZ *= 0.98;			rotY += (soundChannel.rightPeak-0.1)*0.4;			rotY *= 0.97;						sphere.rotationY += rotY;			sphere.rotationX += (rotZ+rotY)*0.3;						var arr:Array = [];			for (var i:int=0; i<circles.length; i++) {				var circle:SphereMusicCircle = circles[i] as SphereMusicCircle;								// depth sort				var mtx:Matrix3D = circle.dot1.transform.getRelativeMatrix3D(this);				arr.push({c:circle,z:mtx.position.z});			}						arr.sortOn("z",Array.NUMERIC|Array.DESCENDING);			var baseZ:Number = sphere.z;			for (i=0; i<arr.length; i++) {				// zsort the circles:				circle = arr[i].c as SphereMusicCircle;				var z:Number = arr[i].z;				sphere.setChildIndex(circle,i);								// swap the dots based on position:				circle.setChildIndex(circle.dot2,(z > baseZ ? 0 : 1));								// darken circle elements based on distance from the camera:				var b:Number = Math.min(1, 1+(baseZ-z)/250);				var o:Number = Math.max(0,(baseZ-z)/200*64);				circle.transform.colorTransform = new ColorTransform(b,b,b,1,o*0.7,o*0.2,o,0);				// focus depth blur effect, warning, very slow:				/*				b = z/200;				if (b < 0) { b *= -10; }				circle.filters = (b > 2) ? [new BlurFilter(b,b,1)] : [];				*/			}		}				private function loadMusic():void {			var sound:Sound = new Sound(new URLRequest("music.mp3"));			sound.addEventListener(IOErrorEvent.IO_ERROR,handleError);			soundChannel = sound.play();		}				private function handleError(evt:Event):void {}	}}